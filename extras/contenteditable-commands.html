<!DOCTYPE html>
<html>

<head>
    <title>Content-editable element with text-color highlights</title>

    <style>
        #editdiv {
            outline: 0px solid transparent;
        }
        [contenteditable=true]:empty:before {
            content: attr(placeholder);
            display: block;
            font-family: sans-serif;
            font-size: 12px;
            color: gray;
        }
    </style>
</head>

<body>

<input type="text" id="searchstr" value="red green blue"><br>
<br>
<div id="editdiv" contenteditable="true" placeholder="Type here...">thar be red in here</div>
<br>
<button onclick="hightlightText();">highlight listed words</button>

<script src="contenteditable-util.js"></script>
<script>
    var util = contentEditableUtil;

    var searchstrEl = document.getElementById('searchstr');
    var containerEl = document.getElementById('editdiv');

    var absolutePosition = -1;

    containerEl.addEventListener('keydown', onKeyDown, false);
    //containerEl.addEventListener('keydown', onKeyUp, false);
    //containerEl.addEventListener('click', isCursorWithinHighlightableWord, false);
    //containerEl.addEventListener('blur', hightlightText, false);

    setTimeout(function () {
        containerEl.focus();
    }, 250);

    function onKeyDown(e) {
        var len = this.textContent.replace(/[\n\r]+/g, '').length;

        // maxlength: allow backspace and arrow left and right keys
        // prevent hard returns, which introduces bugs
        if ((len >= 50 && !isInertKeyCode(e.keyCode)) || e.keyCode === 13) {
            e.preventDefault();
        }
    }

    function onKeyUp(e) {
        // get context: event occurs within span, then remove node and replace with plain text node
        if (!/^(37|39)$/.test(e.keyCode)) {
            removeHighlight();
        }

        // run check on space, right and left arrows
        if (/^(32|37|39)$/.test(e.keyCode)) {
            // test alternative functions to highlightText
            // one that tests cursor location relative to highlight-able words
            isCursorWithinHighlightableWord();
        }
    }

    function isCursorWithinHighlightableWord() {
        util.getRangeWord();
    }

    function hightlightText() {
        if (containerEl.firstChild.textContent.length === 0) {
            return;
        }

        var wordList, selection;

        saveCursor();

        wordList = searchstrEl.value.split(' '),
                selection = window.getSelection();

        // in case text is split up into different nodes
        containerEl.normalize();

        wordList.forEach(function (word) {
            var i = 0, childNode, str, j = 0,
                    jlen = wordList.length,
                    start, end, range;

            for(i; i<containerEl.childNodes.length; i++) {
                childNode = containerEl.childNodes[i];
                if (childNode.nodeName === '#text') {
                    str = childNode.nodeValue,
                            start = str.indexOf(word),
                            end = start + word.length,
                            range = document.createRange();

                    if (start > -1) {
                        range.setStart(childNode, start);
                        range.setEnd(childNode, end);

                        selection.removeAllRanges();
                        selection.addRange(range);

                        document.execCommand('styleWithCSS', false, true);
                        document.execCommand('bold', false);
                        document.execCommand('foreColor', false, 'red');
                    }
                }
            }
        });

        selection.removeAllRanges(); // This prevents default select highlight and prevents bold toggle.

        restoreCursor();
    }

    function saveCursor() {
        var parentNode = getSelectedNode(true),
                startOffset,
                childIndex,
                nodeList,
                text,
                i,
                len = 0;
        if (!isOrContainedBy(containerEl, parentNode)) {
            return;
        }
        absolutePosition = -1;
        nodeList = Array.prototype.slice.call(containerEl.childNodes);
        if (parentNode === containerEl && nodeList.length === 1) {
            startOffset = getStartOffset();
            absolutePosition = startOffset;
        } else {
            childIndex = getChildNodeIndex(parentNode),
                    startOffset = getStartOffset();
            if (childIndex === -1) {
                parentNode = getSelectedNode();
                childIndex = getChildNodeIndex(parentNode);
            }
            for(i=0; i<childIndex; i++) {
                text = getFirstNodeText(nodeList[i]);
                len += text.length;
            }
            absolutePosition = len + startOffset;
        }
        //console.log(absolutePosition);
    }

    function restoreCursor() {
        var nodeList,
                i,
                childNode,
                prevLen = 0,
                len = 0,
                startOffset,
                textNode;
        if (absolutePosition !== -1) {
            nodeList = Array.prototype.slice.call(containerEl.childNodes);
            for(i=0; i<nodeList.length; i++) {
                childNode = nodeList[i];
                textNode = getFirstNodeText(childNode, true);
                prevLen = len;
                len += textNode.textContent.length;
                if (absolutePosition <= len) {
                    startOffset = absolutePosition - prevLen;
                    util.setCaretPosition(textNode, startOffset);
                    break;
                }
            }
        }
    }

    function getFirstNodeText(node, returnNode) {
        var i, text;
        if (node.nodeName === '#text') {
            return returnNode ? node : node.textContent;
        } else {
            for (i=0; i<node.childNodes.length; i++) {
                text = getFirstNodeText(node.childNodes[i], returnNode);
                if (text) {
                    return text;
                }
            }
        }
        return undefined;
    }

    function isStyleNode(node) {
        var nodeType = node.nodeName.toLowerCase();
        return /^(span|font|b|strong)$/.test(nodeType);
    }

    // backspace, right and left arrows are 'inert' in that they should be ignored when preventing default keydown event
    function isInertKeyCode(keyCode) {
        return /^(8|37|39)$/.test(keyCode);
    }

    function removeHighlight() {
        var selectedNode = getSelectedNode(true),
                startOffset,
                textNode;
        if (isStyleNode(selectedNode)) {
            startOffset = getStartOffset();
            textNode = document.createTextNode(selectedNode.textContent);
            selectedNode.parentNode.replaceChild(textNode, selectedNode);
            // still need to set the cursor in the proper position, else the new key will drop in front
            util.setCaretPosition(textNode, startOffset);
            // some browsers nest elements (e.g. font/b or font/strong), so do it again
            removeHighlight();
        }
    }

    function getStartOffset() {
        var selection = window.getSelection(),
            range;
        if (selection.rangeCount > 0) {
            range = selection.getRangeAt(0);
            return range.startOffset;
        }
    }

    function getSelectedNode(parent) {
        var selection = window.getSelection(),
            range, container;
        if (selection.rangeCount > 0) {
            range = selection.getRangeAt(0);
            container = parent ? range.startContainer.parentNode : range.startContainer;
            return container;
        }
    }

    function getChildNodeIndex(node, level) {
        var i, parent, nodeList, level = level || 0;
        // limit to two levels
        if (level > 2) {
            return -1;
        }
        // traverse parentNode tree until you reach containerEl, then find child index
        if (node === containerEl) {
            parent = node;
        } else if (node.parentNode === containerEl) {
            parent = node.parentNode;
        } else {
            i = getChildNodeIndex(node.parentNode, level+1);
            if (i != -1) {
                return i;
            }
        }
        if (parent) {
            nodeList = Array.prototype.slice.call(parent.childNodes);
            return nodeList.indexOf(node);
        }
        return -1;
    }

    function isOrContainedBy(node, testNode) {
        var isSame = node === testNode;
        if (isSame) {
            return true;
        }
        if (node.hasChildNodes()) {
            return node.contains(testNode);
        }
        return false;
    }

    // archives

    function getPreviousCount(text, selectedNodeIndex, startOffset) {
        var nodeList = Array.prototype.slice.call(containerEl.childNodes),
                nodeText,
                count = 0,
                i,
                str;
        if(nodeList.length > 0) {
            for(i=0; i<selectedNodeIndex; i++) {
                nodeText = getFirstNodeText(nodeList[i]);
                if (nodeText === text) {
                    count++;
                }
            }
        } else {
            str = containerEl.textContent;
            for(i=0; i<str.length;i++) {
                if (i < startOffset && str[i] === text) {
                    count++;
                }
            }
        }
        return count;
    }

</script>
<script src="contenteditable-util.spec.js"></script>

</body>

</html>